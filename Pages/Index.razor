@page "/"
@using BlazorGinRummy.GinRummyGame.Helpers;
@using BlazorGinRummy.GinRummyGame.Models;
@inject GinRummyGameService ginRummyGameService;

<PageTitle>Index</PageTitle>

@foreach (var msg in ginRummyGameService.GameStateMessage)
{
    <p><strong>@msg</strong></p>
}

@*<ol>
    @foreach (var card in ginRummyGameService.GetDeck())
    {
        <li>@card.ToString()</li>
    }
</ol>*@

<ol>
    @foreach (var card in ginRummyGameService.handPlayerOne)
    {
        <li>@card.FullNameString()</li>
        <img width="60" height="60" src="@($"SVG-cards/{card.FullNameString()}.svg")" @onclick="@(async () => await CardInHandImgClicked(card))">
    }
</ol>
@if(ginRummyGameService.isPlayerOneTurn && ginRummyGameService.playerOnePickedUpCard != null)
{
    <img width="60" height="60" src="@($"SVG-cards/{ginRummyGameService.playerOnePickedUpCard.FullNameString()}.svg")" @onclick="@(async () => await CardFromDeckImgClicked())">
}

<p>@ginRummyGameService.HandToString(ginRummyGameService.handPlayerTwo)</p>
<br />
<p>Discard Pile: @ginRummyGameService.discardPile.Last().ToString()</p>
<img width="60" height="60" src="@($"SVG-cards/{ginRummyGameService.discardPile.Last().FullNameString()}.svg")" @onclick="@(() => DiscardPileImgClicked())">
<br />
<p>@ginRummyGameService.HandToString(ginRummyGameService.handPlayerOne)</p>
<br />

<br />

<button class="btn btn-primary" @onclick="@(() => DeckPickupButtonClicked())" disabled="@((!ginRummyGameService.isPlayerOneTurn)||(ginRummyGameService.isPlayerOneMakingFirstCardChoice))">Pick Up From Deck</button>

@if(ginRummyGameService.isPlayerOneMakingFirstCardChoice)
{
    <button class="btn btn-danger" @onclick="@(() => PassButtonClicked())" disabled="@(!ginRummyGameService.isPlayerOneTurn)">Pass Turn</button>
}
@if(ginRummyGameService.canPlayerOneKnock)
{
    <button class="btn btn-danger" @onclick="@(() => KnockButtonClicked())" disabled="@(!ginRummyGameService.isPlayerOneTurn)">Knock (END GAME)</button>
    <button class="btn btn-secondary" @onclick="@(() => KeepPlayingButtonClicked())" disabled="@(!ginRummyGameService.isPlayerOneTurn)">Don't Knock (KEEP PLAYING)</button>
}

<p>@ginRummyGameService.isPlayerOneTurn</p>

<p>@playerOneNumber</p>

@code {
    // TODO: add private variables in here to control the html tag attributes. Add logic to lock everything if game is over
    private int playerOneNumber;

    private void KnockButtonClicked()
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;
        ginRummyGameService.PlayerOneChoseKnock();
    }

    private void KeepPlayingButtonClicked()
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;
        ginRummyGameService.PlayerOneChoseKeepPlaying();
    }

    private void DeckPickupButtonClicked()
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;
        if (ginRummyGameService.isPlayerOneMakingFirstCardChoice) return;

        ginRummyGameService.PlayerOnePickedUpCardFromDeck();
    }

    private void DiscardPileImgClicked()
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;

        ginRummyGameService.PlayerOnePickedUpCardFromDiscardPile();
    }

    private async Task CardFromDeckImgClicked()
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;
        if (!ginRummyGameService.isPickedUpCardSet) return;

        ginRummyGameService.PlayerOneChoseDiscard_CardFromDeck(); // TODO: refactor with above line, change to use Card object itself instead of int
        StateHasChanged();

        // TODO: refactor
        await Task.Delay(1000); // Delay so that user can better see what decision the computer player made.
        ginRummyGameService.SimpleAgentPlaysHand();
        StateHasChanged();
    }

    private async Task CardInHandImgClicked(Card card)
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;
        if (!ginRummyGameService.isPickedUpCardSet) return;

        playerOneNumber = ginRummyGameService.handPlayerOne.IndexOf(card);

        ginRummyGameService.PlayerOneChoseDiscard(playerOneNumber); // TODO: refactor with above line
        StateHasChanged();

        if (ginRummyGameService.canPlayerOneKnock) return;
        if (ginRummyGameService.isPlayerOneMakingFirstCardChoice) return;

        await Task.Delay(1000); // Delay so that user can better see what decision the computer player made.
        ginRummyGameService.SimpleAgentPlaysHand();
        StateHasChanged();
    }

    private void PassButtonClicked()
    {
        if (!ginRummyGameService.isPlayerOneTurn) return;

        ginRummyGameService.PlayerOneChosePass();
    }

    //private async Task SubmitPlayerOneTurn()
    //{
    //    ginRummyGameService.PlayerOneChoseDiscard(true, playerOneNumber);
    //    StateHasChanged();

    //    await GetComputerTurn();
    //}

    //private async Task GetComputerTurn()
    //{
    //    await Task.Delay(1000); // Delay so that user can better see what decision the computer player made.
    //    ginRummyGameService.PlayerOneChoseDiscard(false, 9);
    //    StateHasChanged();
    //}
}



@*<ImagesTest />*@

@*<GinRummyTest />*@

                @*
@if(@ginRummyGameService.isPlayerOneTurn)
{
    <p>Player one turn</p>
    <input type="number" @bind-value="@playerOneNumber" min="0" max="9">
    <button @onclick="@SubmitPlayerOneTurn">Submit</button>

}
else
{
    /* 
    
    This is extremely hacky but this is the only method I could get to work so that delays could be 
    programmed in without blocking prior UI updates.
      
    */

    <img src="loading.jpg" @onload="@(async () => await GetComputerTurn())" hidden>
}




    //private void SubmitPlayerOneTurn()
    //{
    //    ginRummyGameService.PlayerChooseDiscard(true, playerOneNumber);
    //    StateHasChanged();
    //}

    <p>Player one turn</p>
<input type="number" @bind-value="@playerOneNumber" min="0" max="9">
<button @onclick="@(async () => await SubmitPlayerOneTurn())" disabled="@(!ginRummyGameService.isPlayerOneTurn)">Submit</button>

*@

